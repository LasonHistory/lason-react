# lason-react

## 哲学
旨在提供彻底的组件化开发能力。
组件化：组件只关心外部输入，输入一致则输出一致；输出可以嵌套组件；组件即对象，以组件内的哲学完备为终极目的。
对象：内部是黑盒，不影响外部；对象是一个基本单元，只负责特定的业务。
对于黑盒而言，对象的定义很简单，但是现实往往没有太多的黑盒，一个特定业务的黑盒一定是由很多相互耦合的对象组成的。不同黑盒之间的交互必须有几种公共介质。这样可以构成完整的架构。

### 基本概念
公共介质：信息或能量，驱动系统运转
黑盒：系统
总线：管理外部物质和信息

### 架构
输入信息，总线
||
黑盒——黑盒内部变化
|
输出信息，总线

### 案例
场景：一个表单，用户点击输入，右侧有实时生成信息
1、根节点
总线：数据
黑盒：表单和实时信息
介质：输入数据
2、表单
总线：点击数据
黑盒：表单项
介质：点击数据
input[]
class Comp {
    blackBox[]
    media[]
}
input——box的最大公约数input为Comp的media——media作为input向所有box递归
静态结构下编译就可以知道每个Comp的media，对应的，应该有管理这一层media的总线。也就是说静态下，Comp管理当前media以及不同box的media交互逻辑。
本来根节点可以管理所有media和总线，这种组件思想问题在于如何将其拆解到最细的粒度上，你可以所有东西写在根节点，然后编译成最细粒度的代码，但是这样就失去了编程的意义。
这种编程的极致就是ArkUI

## UI分析
具体而言，视图操作只应该响应最少的 dom 变化。假设一个操作，导致某些节点变化；那么他们公共父节点的以外节点是不用改变的；节点只有属性变化，则修改即可；新增子节点，需要计算、构建子节点；删除则删除。以上是一个节点的情况，一个操作，会对多个节点产生修改的场景，可能存在冗余修改，比如父节点删除了子节点，那么子节点的修改就是多余的；两个节点新增的是同样的节点，那么这个节点的多次构建也是多余的。
自顶向下的逐步修改：天然解决第一种情况；第二种则无法避免，新建第一个时不知道后面是否会用到相同的节点。
收集所有修改信息，统一分析，过滤掉冗余修改：收集策略是问题；分析策略也是问题。